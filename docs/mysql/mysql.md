### MySQL 相关问题总结

### 索引哪些情况会失效

+ 查询条件中包含 or ，like通配符，非联合索引中的第一个列
+ 在索引列上使用 mysql 的内置函数，索引失效
+ 对索引列运算( + - * /)，索引失效
+ 索引字段上使用 is null，is not null，!= ，<>，not in 时，可能会导致索引失效
+ mysql 估计使用全表扫描要比使用索引快

### 索引不适合哪些场景

+ 数据量少
+ 更新数据比较频繁
+ 区分度低的字段(如性别)

### 索引的数据结构  (B+树)

#### 二叉查找树 平衡二叉树 的劣势

+ 二叉查找树在最坏情况会变成链表，树的高度急剧增加，数据查询相当于全表扫描
+ 平衡二叉树通过旋转使得树一直保证平衡状态。 平衡二叉树每个节点只存储一个键值和数据，当需存储海量的数据时，树的节点会非常多，而且高度会很高，每次查找数据会进行多次磁盘 IO 

#### B树与B+树

B树(Balance Tree)每个节点能存储更多的键值和数据，子节点的个数一般称为阶，如下图的三阶B树，每个节点存储了两个数据节点以及三个指向子节点的指针，每个节点也称为页，即磁盘块，mysql中数据读取的基本单位都是页，因此B树的设计也符合mysql中索引的底层数据结构

![B树](B树.jpg)

B+树是对B树的进一步优化。B+树的非叶子节点上不存储数据，仅存储键值，在数据库页的大小是固定的(Innodb中页的默认大小是16KB)。不存储数据仅存储键值的情况下，会使树的阶数更大，树就会更矮更胖，查询所需磁盘IO次数会进一步减少，提升查询效率。B+树的阶数等于键值的数量。B+树的叶子节点存储数据，且是按照顺序排列的，使得范围查找，排序查找，分组查找以及去重查找变得异常简单(B树的数据分散在各个节点)。B+树上的各个页之间通过双向链表连接，叶子节点中的数据是通过单向链表连接的。     

![B+树](B+树.jpg)

### 聚集索引与非聚集索引

1.聚集索引(聚簇索引)：以主键作为B+树索引的键值而构建的B+树索引，叶子节点存储表中所有数据

2.非聚集索引(非聚簇索引)：以主键以外的列值作为键值构建的B+树索引，叶子节点不存储数据，而是存储该列对应的主键，想要查找数据还需要根据主键再去聚集索引中进行查找，这一过程称为 回表

### 如何优化SQL

+ explain分析慢SQL
+ 优化SQL结构，避免返回不必要的数据
+ 适当分批量进行
+ 分库分表
+ 读写分离

### 分库分表方案

+ 水平分库：以字段为依据，按照一定的策略(如 hash)，将一个库中的数据拆分到多个库中
+ 水平分表：以字段为依据，按照一定的策略(如 hash)，将一个表中的数据拆分到多个表中
+ 垂直分库：以表为依据，按照业务归属不同，将不同的表拆分到不同的库中
+ 垂直分表：以字段为依据，按照字段的活跃性，将表中字段拆分到不同的表中(主表和扩展表)

### 常见的分库分表中间件

+ sharding-jdbc(当当)
+ Mycat
+ TDDL(淘宝)

### 分库分表可能遇到的问题

+ 事务问题：分布式事务
+ 跨节点Join问题：分两次查询实现
+ 跨节点的 count，order by，group by 以及聚合函数问题：分别在各个节点上得到结果后在应用程序端进行合并
+ 数据迁移，容量规划，扩容等问题
+ ID问题：数据库被切分后不能再依赖数据库自身的 主键生成机制，可考虑UUID

### InnoDB 与 MyISAM 的区别

+ InnoDB支持事务，MyISA不支持事务
+ InnoDB支持外键，MyISAM不支持外键
+ InnoDB支持MVCC
+ select count(*) from table，MyISAM更快，因为其有一个变量保存了整个表的总行数
+ InnoDB支持表、行级锁，MyISAM支持表级锁
+ InnoDB必须有主键，MyISAM可以没有主键

#### 悲观锁

悲观锁认为被它保护的数据是极其不安全的，每时每刻都有可能变动，一个事务拿到悲观锁后，其他任何事务都不能对该数据进行修改，只能等待锁被释放才可以执行。

> 悲观锁认为数据修改产生冲突的概率比较大，故在更新之前，我们需显示地对要修改的记录进行加锁，直到自己修改完再释放锁。加锁期间只有自己可以进行读写，其他事务只能读不能写。

#### 乐观锁

乐观锁认为数据的变动不会太频繁。因此它允许多个事务同时对数据进行变动，通常使用版本或时间戳来实现

> 乐观锁认为数据修改产生冲突的概率并不大，多个事务在修改数据之前需先查出版本号，在修改时把当前版本号作为修改条件，只会有一个事务可以修改成功，其他事务则会失败。

### MySQL主从复制

+ 步骤一：主库的更新时间(update、insert、delete)被写道binlog
+ 步骤二：从库发起连接，连接到主库
+ 步骤三：主库创建一个binlog dump thread，把binlog的内容发送到从库
+ 步骤四：从库启动后，创建一个I/O线程，读取主库传过来的binlog内容并写入到relay log
+ 步骤五：从库还会创建一个SQL线程，从relay log里面读取内容，从ExecMasterLog_Pos位置开始执行读取到的更新事件，将更新的内容写入到从库的db中。

### MySQL主从延迟

一个服务器开放 N 个链接给客户端来连接，这样可能会有大并发的更新操作，但是从服务器里读取 binlog 的线程只有一个，当某个SQL在从服务器上执行的时间稍长或者由于某个SQL要进行锁表就会导致，主服务器的SQL大量积压，未被同步到从服务器里，这就导致了主从不一致，即主从延迟。

###  数据库三大范式

+ 第一范式：数据表中的每一列(每个字段)都不可以再拆分
+ 第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分
+ 第三范式：在满足第二范式的基础上，表中的非主键只依赖于主键，而不依赖于其他非主键

### MySQL事务四大特性

> 事务：由一个有限的数据库操作序列组成，这些操作要么全部执行，要么全部不执行，是一个不可分割的工作单位。

+ 原子性(Atomicity)：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行
+ 一致性(Consistency)：指在事务开始之前和事务结束以后，数据不会被破坏(转账场景)
+ 隔离性(Isolation)：多个事务并发访问时，事务之间是相互隔离的，即一个事务不影响其他事务运行效果
+ 持久性(Durability)：表示事务完成以后，该事务对数据库所作的操作更改，将持久地保存在数据库之中

### 脏读、不可重复读与幻读

事务并执行发过程中，可能会出现一系列问题

现有如下数据

| id   | username | money |
| ---- | -------- | ----- |
| 1    | aaa      | 100   |
| 2    | bbb      | 200   |

假设现在有两个事务A、B

+ 脏读 (事务A读取到事务B未提交的数据)

  假设A查询 bbb 的数据前，id = 2 的数据被事务B 修改了

  最后事务A 读到的是 修改后的余额

  | 时间编号 | 事务A                                       | 事务B                                                  |
  | -------- | ------------------------------------------- | :----------------------------------------------------- |
  | 1        | Begin                                       |                                                        |
  | 2        |                                             | Begin                                                  |
  | 3        |                                             | update account set money = 180 where username = 'bbb'; |
  | 4        | select * from table where username = 'bbb'; |                                                        |
  | 5        | 最后的结果是180                             |                                                        |

+ 不可重复读(在事务A范围内，两个相同的查询，读取同一条记录，却返回不同的结果)

  假设事务A先去查询 aaa 的数据，查到结果是 100

  此时事务B对 aaa 账务余额更改，减了10，提交事务

  事务A再去查询 aaa 的数据，查到的结果是 90

  | 时间编号 | 事务A                                            | 事务B                                                 |
  | -------- | ------------------------------------------------ | ----------------------------------------------------- |
  | 1        | Begin                                            |                                                       |
  | 2        | select money from account where username = 'bbb' |                                                       |
  | 3        | 查询的结果是200                                  |                                                       |
  | 4        |                                                  | Begin                                                 |
  | 5        |                                                  | update account set money = 180 where username = 'bbb' |
  | 6        |                                                  | Commit                                                |
  | 7        | select money from account where username = 'bbb' |                                                       |
  | 8        | 查询的结果是180                                  |                                                       |
  | 10       | Commit                                           |                                                       |

+ 幻读(事务A查询两次同一个范围的结果集，由另一个事务的增删操作导致查询的结果集不一致)

  事务A先查询id小于5的账户记录，得到记录 id = 1 和 id = 2 的两条记录

  事务B插入一条 id = 4 的记录，并且提交

  事务A再去执行相同的查询，得到了 3条记录

  | 时间编号 | 事务A                                                        | 事务B                                             |
  | -------- | ------------------------------------------------------------ | ------------------------------------------------- |
  | 1        | Begin                                                        |                                                   |
  | 2        | select * from account where id < 5;                          |                                                   |
  | 3        | 返回 id = 1，2 的两条记录                                    |                                                   |
  | 4        |                                                              | Begin                                             |
  | 5        |                                                              | insert account(username,money) values ('C', 300); |
  | 6        |                                                              | Commit                                            |
  | 7        | select * from account where id < 5;                          |                                                   |
  | 8        | 返回 id = 1，2 两条记录                                      |                                                   |
  |          | update account set money = 280 where username = 'C';(修改事务B新增的记录) |                                                   |
  | 10       | select * from account where id < 5;                          |                                                   |
  | 11       | 返回 id = 1，2，3 三条记录                                   |                                                   |

> 不可重复读与幻读的区别：
>
> + 不可重复读的重点是修改：数据内容发生变化
> + 幻读的重点在于新增或者删除：数据的数量发生了变化

### 事务的隔离级别

| 隔离级别         | 脏读 | 不可重复读 | 幻读 |
| ---------------- | ---- | ---------- | ---- |
| read uncommitted | YES  | YES        | YES  |
| read committed   | NO   | YES        | YES  |
| repeatable read  | NO   | NO         | YES  |
| serializable     | NO   | NO         | NO   |

### MySQL隔离级别的实现原理

实现隔离机制的方法主要有两种：

1. 读写锁 (RU Serializable)
2. 一致性快照读，即 MVCC (RC RR)

+ 读未提交(Read Uncommitted)

  事务读不加锁，不阻塞其他事务的读和写

  事务写阻塞其他事务写，不阻塞其他事务读

+ 串行化(Serializable)

  所有 SELECT 语句会隐式转化为 SELECT ... FOR SHARE，即加共享锁

  读加共享锁，写加排他锁，读写互斥。如果有未提交的事务正在修改某些行，所有 select 这些行的语句都会阻塞

### MVCC的实现原理

MVCC，又叫多版本并发控制，它是同个读取历史版本的数据，来降低并发事务冲突，从而提高并发性能。

#### 隐式字段

对于 InnoDB 存储引擎，每一行记录都有两个隐藏列 DB_TRX_ID DB_ROLL_PTR，如果表中没有主键和非NULL唯一键时，则还会有第三个隐藏的主键列 DB_ROW_ID

+ DB_TRX_ID：记录每一行最近一次修改它的事务ID，大小为 6 字节
+ DB_ROLL_PTR：记录指向 undo 日志的指针，大小为 7 字节
+ DB_ROW_ID：单调递增的行ID，大小为 6 字节

#### undo 日志

+ 事务未提交时，被修改数据的镜像(修改前的旧版本)会存到 undo 日志里。以便事务回滚时，恢复旧版本数据，撤销未提交事务数据对数据库的影响。

+ undo 日志是逻辑日志。当 delete 一条记录时，undo log 中会记录一条对那个的 insert 记录，当 udpate 一条记录时，它记录一条对应相反的 update 记录。
+ 存储 undo 日志的地方，就是回滚段。

#### 快照读 & 当前读

> 快照读：读取的是记录数据的可见版本(旧版本数据)，不加锁，普通的select语句都是快照读
>
> 当前读：读取的是记录数据的最新版本，显示加锁的都是当前读

#### Read View

+ Read View 就是事务执行快照读时，产生的读视图
+ 事务执行快照读时，会产生数据库系统当前的一个快照，记录当前系统中还有哪些活跃的读写事务，把它们放到一个列表里，记作 limited_ids
+ Read View 主要是用来做可见性判断，即判断当前事务可见哪个版本的数据（DB_TRX_ID not in limited_ids 表明该版本的事务不是活跃的状态，当前事务可以见到该版本事务修改后的结果）

> 注：RR 和 RC 最大的区别是：RC 每次读取数据前都生成一个 ReadView，而 RR 只在第一次读取数据时生成一个 ReadView

### MySQL 锁的概念

#### 共享锁与排他锁

+ 共享锁（S锁）：允许持锁事务读取一行
+ 排他锁（X锁）：允许持锁事务更新或者删除一行

若事务 T1 持有行 r 的 s 锁，当另一个事务 T2 请求 r 的 s 锁时，T1 T2都会持有 r 行的 s 锁；

若事务 T1 持有行r 的 x 锁，当另一个事务 T2 请求 r 的 x 、s 锁时，T2 都必须等待 T1 释放

#### 记录锁

+ 记录锁是最简单的行锁，仅仅锁住一行。如 SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE
+ 记录锁永远都是加在索引上，会阻塞其他事务对其插入、更新、删除

#### 间隙锁

+ 间隙锁是一种加在两个索引之间的锁，或者是第一个索引之前或者最后一个索引之后的间隙
+ 间隙锁锁住的是一个区间 ？
+ 间隙锁只阻止其他事务插入到间隙中，他们不阻止其他事务在同一个间隙上获得间隙锁 ？

#### Next - Key Locks

+ Next - key 锁是记录锁和间隙锁的组合，指的是加在某条记录以及这条记录前面间隙上的锁

> 查看自动提交事务配置：show VARIABLES like 'autocommit'; 
> 查看隔离级别：select @@tx_isolation;
> 设置隔离级别：set session transaction isolation level repeatable read;
> 查询当前活跃事务：select * from information_schema.INNODB_TRX;



索引的一些潜规则(覆盖索引 回表 B+树 最左前缀原则 索引下推)

### 覆盖索引
SQL只需要通过辅助索引就可以返回查询所需要的数据，而不必通过聚簇索引查到主键后再去查询数据。

### 回表
SQL通过辅助索引查询到对应数据的主键，然后通过聚簇索引查到对应的数据记录

### 最左匹配原则
对于联合索引最左优先，查询条件中，以最左边为起点任何连续的索引都能匹配上。同时遇到范围查询(> < between like)就会停止匹配。查询条件中顺序无关。

### 索引下推
ICP(index condition pushdown)，在非主键索引上的优化，可以有效减少回表的次数，大大提高查询的效率。

For Instance：

> select * from user where name like 'a%' and age = 20;  
>
> user 表有联合索引 (name, age)
>
> | name | age  | id   |
> | ---- | ---- | ---- |
> | aaa  | 30   | 1    |
> | aab  | 20   | 2    |
> | bbb  | 20   | 3    |

如果没有ICP(mysql version before 5.6) 

+ 会忽略age字段，在(name, age)树上找到了两个结果，id分别为1和2，然后进行两次回表查询

若使用ICP

+ 在索引内部判断age是否等于20，对于不等于20的记录直接跳过，因此只进行了一次回表查询




